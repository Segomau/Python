# -*- coding: utf-8 -*-
"""Entrenamiento Neuronal

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fbFj1GPAcFbOct1mPkupb9p6T8qi6k_K
"""

# Importar librerías necesarias
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
import numpy as np
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
from google.colab import files

# Subir el archivo
uploaded = files.upload()

# Cargar los datos
df = pd.read_csv('winequality-red.csv', sep=';')

# Separar características (features) y el objetivo (target)
features = df.drop('quality', axis=1)  # Todas las columnas excepto 'quality'
target = df['quality']                 # La columna 'quality' es la que queremos predecir

# Dividir los datos en conjunto de entrenamiento (80%) y prueba (20%)
X_train, X_val, y_train, y_val = train_test_split(features, target, test_size=0.2, random_state=42)

# Estandarizar los datos para mejorar el rendimiento de la red neuronal
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_val_scaled = scaler.transform(X_val)

# Definir la arquitectura de la red neuronal
model = Sequential()
model.add(Dense(64, input_dim=X_train_scaled.shape[1], activation='relu'))  # Capa oculta con 64 neuronas
model.add(Dense(32, activation='relu'))  # Segunda capa oculta con 32 neuronas
model.add(Dense(1))  # Capa de salida con 1 neurona (predicción del valor quality)

# Compilar el modelo
model.compile(optimizer='adam', loss='mean_squared_error')

# Entrenar la red neuronal
model.fit(X_train_scaled, y_train, epochs=50, batch_size=10, verbose=1)

# Realizar predicciones sobre el conjunto de prueba
y_predicted = model.predict(X_val_scaled).flatten()

# Convertir las predicciones a clases discretas (redondear los valores predichos)
y_predicted_classes = np.round(y_predicted).astype(int)

# Limitar las predicciones al rango de calidad (asumiendo que la calidad del vino está entre 0 y 10)
y_predicted_classes = np.clip(y_predicted_classes, 0, 10)

# Tomar los primeros 10 valores reales y predichos
y_true_classes = y_val[:10].astype(int)  # Asegurarse de que los valores reales sean enteros
y_predicted_classes = y_predicted_classes[:10]  # Tomar solo los primeros 10 valores predichos

# Crear la matriz de confusión
conf_matrix = confusion_matrix(y_true_classes, y_predicted_classes, labels=np.arange(11))

# Mostrar la matriz de confusión
disp = ConfusionMatrixDisplay(confusion_matrix=conf_matrix, display_labels=np.arange(11))
disp.plot(cmap=plt.cm.Blues)  # Usar un mapa de colores azul
plt.title('Matriz de Confusión (Primeros 10 Valores)')
plt.show()